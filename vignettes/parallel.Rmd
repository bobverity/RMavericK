---
title: "Running in parallel"
author: "Bob Verity"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

This vignette demonstrates how to run *rmaverick* in parallel, making use of multiple cores if they are available. Each explored value of K can be run on a separate core, often leading to a significant speedup.

```{r, echo=FALSE}
set.seed(1)
library(rmaverick)
```

First, we must install and load the "parallel" package:

```{r, eval = FALSE}
install.packages("parallel")
```
```{r}
library(parallel)
```

We will need some data to work with, so lets simulate some data and load it into a new project. We will also create a simple parameter set to work with:

```{r}
set.seed(1)
mysim <- sim_data(n = 50, loci = 10, K = 3, admix_on = FALSE)

myproj <- mavproject()
myproj <- bind_data(myproj, mysim$data, ID_col = 1, pop_col = 2, ploidy_col = 3)
myproj <- new_set(myproj, admix_on = FALSE)
```

Before running anything in parallel we need to know how many cores our machine has. You may know this number already, but if you don't then the parallel package has a handy function for detecting the number of cores for you:

```{r}
cores <- detectCores()
```

We then create a cluster object, which creates multiple copies of R running in parallel over different cores. Here we are using all available cores, but if you want to hold some back for other intensive tasks then simply use a smaller number of cores when specifying this cluster.

```{r, eval = FALSE}
cl <- makeCluster(cores)
```

We can then run the MCMC using the usual `run_mcmc()` function, this time passing in the cluster as an argument. Note that output is supressed when running in parallel:

```{r, eval = FALSE}
myproj <- run_mcmc(myproj, K = 1:5, burnin = 1e3, samples = 1e3, rungs = 10, cluster = cl)
```

Finally, it is good practice to shut down the workers once we are finished:

```{r, eval = FALSE}
stopCluster(cl)
```

You should find that this is considerably faster than running the MCMC without passing in the cluster object.

